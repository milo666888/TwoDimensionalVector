<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>向量互動教具</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <style>
    *, *::before, *::after { box-sizing: border-box; }
    body {
      margin: 0; font-family: system-ui, -apple-system, "Noto Sans TC", sans-serif;
      background: #000; color: #f5f5f5; overflow: hidden; width: 100vw; height: 100vh;
    }
    .app-container { height: 100vh; display: flex; flex-direction: column; }
    header { padding: 0.4rem 0.8rem; background: #050505; border-bottom: 1px solid #333; z-index: 100; flex-shrink: 0; }
    header h1 { margin: 0; font-size: 1rem; }
    main { flex: 1; display: flex; min-height: 0; position: relative; }
    
    /* --- 電腦版佈局 --- */
    .canvas-section { flex: 3; position: relative; background: #000; overflow: hidden; }
    #vectorCanvas { width: 100%; height: 100%; background: #000; display: block; touch-action: none; }
    .company-logo { position: absolute; left: 15px; bottom: 15px; height: 40px; opacity: 0.9; pointer-events: none; z-index: 50; }

    .control-section { flex: 1.2; padding: 0.4rem; display: flex; flex-direction: column; gap: 0.4rem; overflow-y: auto; background: #000; border-left: 1px solid #333; }
    .panel { background: #050505; border-radius: 0.3rem; padding: 0.4rem 0.6rem; border: 1px solid #222; font-size: 0.8rem; }
    .panel h2 { margin: 0 0 0.3rem; font-size: 0.85rem; border-bottom: 1px solid #333; padding-bottom: 0.15rem; color: #ddd; }
    
    /* 面板向量符號 (電腦版高度維持) */
    .vec-var { font-family: "Times New Roman", serif; font-style: italic; font-weight: bold; position: relative; display: inline-flex; align-items: center; padding-top: 0.3em; }
    .vec-var::after { content: "⇀"; position: absolute; top: -0.45em; left: 50%; transform: translateX(-50%); font-size: 1.1em; font-weight: normal; }

    .vector-row { display: grid; grid-template-columns: 60px repeat(4, 1fr); gap: 0.2rem; align-items: center; margin-bottom: 0.3rem; font-size: 0.75rem; }
    .label-box { display: flex; align-items: center; gap: 4px; }
    .color-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; flex-shrink: 0; }
    
    input { width: 100%; padding: 0.15rem 0.25rem; background: #111; border: 1px solid #333; color: #f5f5f5; border-radius: 2px; font-size: 0.75rem; }
    button { border: none; border-radius: 0.2rem; padding: 0.3rem 0.6rem; cursor: pointer; background: #2563eb; color: #fff; font-size: 0.75rem; }
    select { background: #111; color: #f5f5f5; border-radius: 0.2rem; border: 1px solid #333; padding: 0.2rem; width: 100%; font-size: 0.75rem; }
    
    .result-display { margin-top: 0.3rem; padding: 0.4rem; background: #111; border-radius: 0.2rem; display: flex; align-items: center; gap: 6px; font-size: 0.8rem; border: 1px solid #222; }
    .info-line { margin: 0.3rem 0; font-size: 0.75rem; color: #bbb; border-bottom: 1px solid #1a1a1a; padding-bottom: 3px; display: flex; align-items: center; gap: 6px; }

    #mobileSettingsBtn { display: none; }
    .close-menu { display: none; }

    /* --- 手機版專屬修正 --- */
    @media (max-width: 768px) {
      .canvas-section { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; padding: 0; }
      #vectorCanvas { border-radius: 0; }
      .company-logo { position: fixed; left: auto; right: 15px; bottom: 15px; height: 35px; z-index: 90; opacity: 1; }
      #mobileSettingsBtn {
        display: flex; position: fixed; right: 60px; bottom: 15px;
        width: 35px; height: 35px; background: #2563eb; border-radius: 50%;
        align-items: center; justify-content: center; z-index: 110;
        box-shadow: 0 4px 12px rgba(0,0,0,0.6); cursor: pointer; font-size: 1.2rem;
      }
      /* 手機版面板符號調高一些 */
      .vec-var::after { top: -0.55em; }

      .control-section {
        position: fixed; bottom: 0; left: 0; width: 100%; height: 80vh;
        z-index: 200; border-left: none; transform: translateY(100%);
        padding: 1rem; border-radius: 1.2rem 1.2rem 0 0; box-shadow: 0 -10px 40px rgba(0,0,0,0.9);
        transition: transform 0.3s ease-out;
      }
      .control-section.active { transform: translateY(0); }
      .close-menu { display: block; text-align: center; padding: 0.6rem; margin-bottom: 1rem; background: #222; border-radius: 0.5rem; color: #fff; font-weight: bold; font-size: 0.85rem; }
    }
  </style>
</head>
<body>
  <div class="app-container">
    <header><h1>向量互動教具</h1></header>
    <main id="mainContainer">
      <section class="canvas-section">
        <canvas id="vectorCanvas"></canvas>
        <img src="company-logo.png" alt="LOGO" class="company-logo">
      </section>
      <div id="mobileSettingsBtn">⚙️</div>
      <section class="control-section" id="controlPanel">
        <div class="close-menu" id="closeMenuBtn">確認並關閉選單 ✕</div>
        <div class="panel">
          <h2>向量輸入 (起點, 向量)</h2>
          <div class="vector-row">
            <div class="label-box"><span class="color-dot" style="background:#60a5fa;"></span><span class="vec-var">A</span></div>
            <input type="number" step="0.1" id="A_tail_x"> <input type="number" step="0.1" id="A_tail_y">
            <input type="number" step="0.1" id="A_dx"> <input type="number" step="0.1" id="A_dy">
          </div>
          <div class="vector-row">
            <div class="label-box"><span class="color-dot" style="background:#4ade80;"></span><span class="vec-var">B</span></div>
            <input type="number" step="0.1" id="B_tail_x"> <input type="number" step="0.1" id="B_tail_y">
            <input type="number" step="0.1" id="B_dx"> <input type="number" step="0.1" id="B_dy">
          </div>
          <div style="display:flex; gap:0.4rem; margin-top:0.4rem;">
            <button id="applyInputBtn" style="flex:1;">套用修改</button>
            <button id="resetBtn">重設</button>
          </div>
        </div>
        <div class="panel">
          <h2>向量運算模式</h2>
          <select id="operationSelect">
            <option value="none">不顯示運算</option>
            <option value="AplusB">A + B</option>
            <option value="BplusA">B + A</option>
            <option value="AminusB">A - B</option>
            <option value="BminusA">B - A</option>
          </select>
          <div class="result-display">
            <span class="color-dot" id="resultDot" style="background:#fb923c; display:none;"></span>
            <span id="addResultText">（未開啟）</span>
          </div>
        </div>
        <div class="panel">
          <h2>詳細資訊</h2>
          <div id="infoA" class="info-line"></div>
          <div id="infoB" class="info-line"></div>
          <div id="infoC" class="info-line"></div>
        </div>
      </section>
    </main>
  </div>

  <script>
    const mobileBtn = document.getElementById('mobileSettingsBtn');
    const closeBtn = document.getElementById('closeMenuBtn');
    const panel = document.getElementById('controlPanel');
    if(mobileBtn) mobileBtn.onclick = () => panel.classList.add('active');
    if(closeBtn) closeBtn.onclick = () => panel.classList.remove('active');

    const canvas = document.getElementById("vectorCanvas");
    const ctx = canvas.getContext("2d");
    let width, height, centerX, centerY, scale = 40;

    function resizeCanvas() {
      const container = (window.innerWidth > 768) ? canvas.parentNode : document.getElementById("mainContainer");
      width = container.clientWidth; height = container.clientHeight;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr; canvas.height = height * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      centerX = width / 2; centerY = height / 2;
      scale = Math.min(width, height) / 10;
      draw();
    }
    window.addEventListener("resize", resizeCanvas);

    const worldToScreen = (x, y) => ({ sx: centerX + x * scale, sy: centerY - y * scale });
    const screenToWorld = (sx, sy) => ({ x: (sx - centerX) / scale, y: (centerY - sy) / scale });

    const vectors = [
      { id: "A", tail: { x: 0, y: 0 }, dx: 3, dy: 2, color: "#60a5fa" },
      { id: "B", tail: { x: 0, y: 0 }, dx: -1, dy: 3, color: "#4ade80" },
    ];
    const f2 = (x) => Math.round(x * 100) / 100;

    const SNAP_TOL = 0.28;
    function getSnapTarget(pos, otherV) {
      const otherHead = { x: otherV.tail.x + otherV.dx, y: otherV.tail.y + otherV.dy };
      if (Math.hypot(pos.x - otherV.tail.x, pos.y - otherV.tail.y) < SNAP_TOL) return { x: otherV.tail.x, y: otherV.tail.y };
      if (Math.hypot(pos.x - otherHead.x, pos.y - otherHead.y) < SNAP_TOL) return { x: otherHead.x, y: otherHead.y };
      let snapX = Math.abs(pos.x - Math.round(pos.x)) < SNAP_TOL ? Math.round(pos.x) : pos.x;
      let snapY = Math.abs(pos.y - Math.round(pos.y)) < SNAP_TOL ? Math.round(pos.y) : pos.y;
      return { x: snapX, y: snapY };
    }

    function drawVectorLabel(text, dx, dy, tx, ty, hx, hy, color) {
      ctx.save();
      const midX = (tx + hx) / 2, midY = (ty + hy) / 2;
      const ang = Math.atan2(hy - ty, hx - tx);
      
      // 手機版判定
      const isMobile = window.innerWidth <= 768;
      const offset = isMobile ? 32 : 26; // 手機版推更遠一點

      const lx = midX + Math.cos(ang - Math.PI / 2) * offset;
      const ly = midY + Math.sin(ang - Math.PI / 2) * offset;

      ctx.fillStyle = color; ctx.font = "italic bold 17px 'Times New Roman'"; ctx.textAlign = "center";
      ctx.fillText(text, lx, ly);

      const charW = ctx.measureText(text).width;
      const sx = lx - charW/2;
      // 手機版符號高度調高 (ly - 23)，電腦版維持 (ly - 18)
      const sy = ly - (isMobile ? 23 : 18); 
      
      ctx.strokeStyle = color; ctx.lineWidth = 1.3; ctx.beginPath();
      ctx.moveTo(sx, sy); ctx.lineTo(sx + 12, sy); ctx.lineTo(sx + 8, sy - 3); ctx.stroke();
      ctx.font = "bold 13px sans-serif"; ctx.textAlign = "left";
      ctx.fillText(`(${f2(dx)}, ${f2(dy)})`, lx + charW/2 + 3, ly);
      ctx.restore();
    }

    function drawArrow(fx, fy, tx, ty, color, label, dx, dy, dash = []) {
      ctx.save(); ctx.strokeStyle = color; ctx.fillStyle = color; ctx.lineWidth = 3; ctx.setLineDash(dash);
      ctx.beginPath(); ctx.moveTo(fx, fy); ctx.lineTo(tx, ty); ctx.stroke();
      ctx.setLineDash([]);
      const headL = 12; const ang = Math.atan2(ty - fy, tx - fx);
      ctx.beginPath(); ctx.moveTo(tx, ty);
      ctx.lineTo(tx - headL * Math.cos(ang - Math.PI/6), ty - headL * Math.sin(ang - Math.PI/6));
      ctx.lineTo(tx - headL * Math.cos(ang + Math.PI/6), ty - headL * Math.sin(ang + Math.PI/6));
      ctx.closePath(); ctx.fill();
      if(label) drawVectorLabel(label, dx, dy, fx, fy, tx, ty, color);
      ctx.restore();
    }

    function getInfoLine(id, color, dx, dy) {
      const dot = `<span class="color-dot" style="background:${color}"></span>`;
      const name = `<span class="vec-var" style="color:${color}">${id}</span>`;
      return `${dot} ${name}：向量 (${f2(dx)}, ${f2(dy)}), 長度 ${f2(Math.hypot(dx, dy))}`;
    }

    function draw() {
      ctx.clearRect(0, 0, width, height);
      ctx.strokeStyle = "#222"; ctx.lineWidth = 1; ctx.beginPath();
      const u = Math.ceil(width / scale) + 5;
      for (let i = -u; i <= u; i++) { 
        ctx.moveTo(centerX + i * scale, 0); ctx.lineTo(centerX + i * scale, height); 
        ctx.moveTo(0, centerY + i * scale); ctx.lineTo(width, centerY + i * scale);
      }
      ctx.stroke();
      ctx.strokeStyle = "#888"; ctx.lineWidth = 1.5; ctx.beginPath();
      ctx.moveTo(0, centerY); ctx.lineTo(width, centerY); ctx.moveTo(centerX, 0); ctx.lineTo(centerX, height);
      ctx.stroke();
      const op = document.getElementById("operationSelect").value;
      const resDot = document.getElementById("resultDot"), resText = document.getElementById("addResultText");
      const A = vectors[0], B = vectors[1];
      drawArrow(worldToScreen(A.tail.x, A.tail.y).sx, worldToScreen(A.tail.x, A.tail.y).sy, worldToScreen(A.tail.x+A.dx, A.tail.y+A.dy).sx, worldToScreen(A.tail.x+A.dx, A.tail.y+A.dy).sy, A.color, A.id, A.dx, A.dy);
      drawArrow(worldToScreen(B.tail.x, B.tail.y).sx, worldToScreen(B.tail.x, B.tail.y).sy, worldToScreen(B.tail.x+B.dx, B.tail.y+B.dy).sx, worldToScreen(B.tail.x+B.dx, B.tail.y+B.dy).sy, B.color, B.id, B.dx, B.dy);
      document.getElementById("infoA").innerHTML = getInfoLine("A", A.color, A.dx, A.dy);
      document.getElementById("infoB").innerHTML = getInfoLine("B", B.color, B.dx, B.dy);
      if (op !== "none") {
        resDot.style.display = "inline-block";
        const vA = '<span class="vec-var">A</span>', vB = '<span class="vec-var">B</span>';
        let s, e, mid, hCol, labelText;
        const Ah = { x: A.tail.x + A.dx, y: A.tail.y + A.dy }, Bh = { x: B.tail.x + B.dx, y: B.tail.y + B.dy };
        const coincides = Math.hypot(A.tail.x - B.tail.x, A.tail.y - B.tail.y) < 0.1;
        if (coincides && (op === "AminusB" || op === "BminusA")) {
          if (op === "AminusB") { s = Bh; e = Ah; labelText = `${vA} - ${vB}`; } else { s = Ah; e = Bh; labelText = `${vB} - ${vA}`; }
          drawArrow(worldToScreen(s.x, s.y).sx, worldToScreen(s.x, s.y).sy, worldToScreen(e.x, e.y).sx, worldToScreen(e.x, e.y).sy, "#fb923c", "C", e.x-s.x, e.y-s.y);
        } else {
          switch(op) {
            case "AplusB": s=A.tail; mid=Ah; e={x:Ah.x+B.dx, y:Ah.y+B.dy}; labelText=`${vA} + ${vB}`; hCol="#4ade80"; break;
            case "BplusA": s=B.tail; mid=Bh; e={x:Bh.x+A.dx, y:Bh.y+A.dy}; labelText=`${vB} + ${vA}`; hCol="#60a5fa"; break;
            case "AminusB": s=A.tail; mid=Ah; e={x:Ah.x-B.dx, y:Ah.y-B.dy}; labelText=`${vA} - ${vB}`; hCol="#4ade80"; break;
            case "BminusA": s=B.tail; mid=Bh; e={x:Bh.x-A.dx, y:Bh.y-A.dy}; labelText=`${vB} - ${vA}`; hCol="#60a5fa"; break;
          }
          drawArrow(worldToScreen(mid.x, mid.y).sx, worldToScreen(mid.x, mid.y).sy, worldToScreen(e.x, e.y).sx, worldToScreen(e.x, e.y).sy, hCol, "", e.x-mid.x, e.y-mid.y, [5, 5]);
          drawArrow(worldToScreen(s.x, s.y).sx, worldToScreen(s.x, s.y).sy, worldToScreen(e.x, e.y).sx, worldToScreen(e.x, e.y).sy, "#fb923c", "C", e.x-s.x, e.y-s.y);
        }
        resText.innerHTML = `<span class="vec-var">C</span> = ${labelText} = (${f2(e.x-s.x)}, ${f2(e.y-s.y)})`;
        document.getElementById("infoC").innerHTML = getInfoLine("C", "#fb923c", e.x-s.x, e.y-s.y);
      } else {
        resDot.style.display = "none"; resText.textContent = "（未開啟運算）";
        document.getElementById("infoC").innerHTML = "";
      }
    }

    // --- 互動系統 (修復電腦版端點拖拉) ---
    let drag = null;
    function getPos(e) {
      const r = canvas.getBoundingClientRect();
      const cx = e.touches ? e.touches[0].clientX : e.clientX;
      const cy = e.touches ? e.touches[0].clientY : e.clientY;
      return { x: cx - r.left, y: cy - r.top };
    }
    
    canvas.addEventListener("mousedown", (e) => {
      const p = getPos(e); 
      // 關鍵：電腦版加強感應半徑 (40px)
      const tol = 40 * 40; 
      for (let i = 1; i >= 0; i--) {
        const v = vectors[i], t = worldToScreen(v.tail.x, v.tail.y), h = worldToScreen(v.tail.x+v.dx, v.tail.y+v.dy);
        // 先判斷是否點到起點/終點
        if ((p.x-t.sx)**2 + (p.y-t.sy)**2 < tol) { drag = { id: v.id, mode: "tail" }; break; }
        if ((p.x-h.sx)**2 + (p.y-h.sy)**2 < tol) { drag = { id: v.id, mode: "head" }; break; }
        // 再判斷是否點到中間平移
        const mx = (t.sx+h.sx)/2, my = (t.sy+h.sy)/2;
        if ((p.x-mx)**2 + (p.y-my)**2 < tol * 2.5) { drag = { id: v.id, mode: "move", offset: screenToWorld(p.x, p.y), oTail: {...v.tail} }; break; }
      }
    });

    window.addEventListener("mousemove", (e) => {
      if (!drag) return; e.preventDefault();
      const w = screenToWorld(getPos(e).x, getPos(e).y);
      const v = vectors.find(vec => vec.id === drag.id);
      const otherV = vectors.find(vec => vec.id !== drag.id);
      
      if (drag.mode === "tail") {
        const head = { x: v.tail.x + v.dx, y: v.tail.y + v.dy };
        const snapped = getSnapTarget(w, otherV);
        v.tail.x = snapped.x; v.tail.y = snapped.y;
        v.dx = head.x - v.tail.x; v.dy = head.y - v.tail.y;
      } else if (drag.mode === "head") {
        const snapped = getSnapTarget(w, otherV);
        v.dx = snapped.x - v.tail.x; v.dy = snapped.y - v.tail.y;
      } else if (drag.mode === "move") {
        const newTail = { x: drag.oTail.x + (w.x - drag.offset.x), y: drag.oTail.y + (w.y - drag.offset.y) };
        const newHead = { x: newTail.x + v.dx, y: newTail.y + v.dy };
        const sT = getSnapTarget(newTail, otherV), sH = getSnapTarget(newHead, otherV);
        if (sT.x !== newTail.x || sT.y !== newTail.y) { v.tail.x = sT.x; v.tail.y = sT.y; }
        else if (sH.x !== newHead.x || sH.y !== newHead.y) { v.tail.x = sH.x - v.dx; v.tail.y = sH.y - v.dy; }
        else { v.tail.x = newTail.x; v.tail.y = newTail.y; }
      }
      syncInputsFromState(); draw();
    });

    window.addEventListener("mouseup", () => drag = null);
    canvas.addEventListener("touchstart", (e) => { 
        const mouseEvt = new MouseEvent('mousedown', {clientX: e.touches[0].clientX, clientY: e.touches[0].clientY});
        canvas.dispatchEvent(mouseEvt);
    }, {passive: false});
    window.addEventListener("touchmove", (e) => {
        const mouseEvt = new MouseEvent('mousemove', {clientX: e.touches[0].clientX, clientY: e.touches[0].clientY});
        window.dispatchEvent(mouseEvt);
    }, {passive: false});
    window.addEventListener("touchend", () => drag = null);

    document.getElementById("applyInputBtn").onclick = () => {
      vectors.forEach(v => {
        v.tail.x = parseFloat(document.getElementById(v.id+"_tail_x").value || 0);
        v.tail.y = parseFloat(document.getElementById(v.id+"_tail_y").value || 0);
        v.dx = parseFloat(document.getElementById(v.id+"_dx").value || 0);
        v.dy = parseFloat(document.getElementById(v.id+"_dy").value || 0);
      });
      draw();
    };
    document.getElementById("resetBtn").onclick = () => location.reload();
    document.getElementById("operationSelect").onchange = draw;

    function syncInputsFromState() {
      vectors.forEach(v => {
        document.getElementById(v.id+"_tail_x").value = f2(v.tail.x); document.getElementById(v.id+"_tail_y").value = f2(v.tail.y);
        document.getElementById(v.id+"_dx").value = f2(v.dx); document.getElementById(v.id+"_dy").value = f2(v.dy);
      });
    }
    resizeCanvas(); syncInputsFromState();
  </script>
</body>
</html>
